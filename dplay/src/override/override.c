/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       override.c
 *  Content:    Implementation of a DirectPlay launching utility
 *
 ***************************************************************************/

#define INITGUID

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <wtypes.h>
#include <cguid.h>

#include "dplay.h"
#include "dplobby.h"

#include "resource.h"

#if defined(UNICODE) || defined(_UNICODE)
#error This app does not support UNICODE
#endif

#define NAMEMAX			200		// string size
#define TIMERID			1		// timer ID to use
#define TIMERINTERVAL	1000	// timer interval
#define MAXSTRLEN		200		// maximum size of temp strings

typedef struct {
	LPDIRECTPLAY4A	lpDPlay;
	GUID			guidInstance;
} STATUSCONTEXT, *LPSTATUSCONTEXT;

// guid for this application
// {126E6180-D307-11d0-9C4F-00A0C905425E}
DEFINE_GUID(OVERRIDE_GUID, 
0x126e6180, 0xd307, 0x11d0, 0x9c, 0x4f, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// prototypes
BOOL CALLBACK	OverrideWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK	SessionsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT 		InitializeOverrideWindow(HWND hWnd, LPDIRECTPLAYLOBBY3A *lplpDPlayLobby);
void			DestroyOverrideWindow(HWND hWnd, LPDIRECTPLAY4A lpDPlay, LPDIRECTPLAYLOBBY3A lpDPlayLobby);
HRESULT 		UpdateAddressInfo(HWND hWnd, LPDIRECTPLAYLOBBY3A lpDPlayLobby3A);
HRESULT 		DoHostOrJoin(HINSTANCE hInstance, HWND hWnd, LPDIRECTPLAYLOBBY3A lpDPlayLobby, BOOL bHost, LPDIRECTPLAY4A *lplpDPlay);
BOOL FAR PASCAL EnumConnectionsCallback(LPCGUID lpguidSP, LPVOID lpConnection, DWORD dwConnectionSize,
										LPCDPNAME lpName, DWORD dwFlags, LPVOID lpContext);
HRESULT 		GetServiceProviderGuid(HWND hWnd, LPGUID lpguidServiceProvider);
void			DeleteServiceProviderCombo(HWND hWnd);
HRESULT 		FillModemComboBox(HWND hWnd, LPDIRECTPLAYLOBBY3A lpDPlayLobby);
BOOL			DlgItemIsChecked(HWND hDlg, int nIDDlgItem);
void			EnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable);
void			ErrorBox(LPSTR lpszErrorStr, HRESULT hr);

// ---------------------------------------------------------------------------
// WinMain
// ---------------------------------------------------------------------------
// Description:             Main windows entry point.
// Arguments:
//  HINSTANCE               [in] Standard windows stuff
//  HINSTANCE               [in]
//  LPSTR                   [in]
//  int                     [in]
// Returns:
//  int
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
					LPSTR lpCmdLine, int nCmdShow )
{
	HRESULT	hr;
	int		iResult = 0;

	// initialize COM library
	hr = CoInitialize(NULL);
	if (FAILED(hr))
	{
		ErrorBox("CoInitialize failed. Error 0x%0X", hr);
		return 0;
	}

	iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_OVERRIDEDIALOG), NULL, OverrideWndProc, (LPARAM) hInstance);

	// Uninitialize the COM library
	CoUninitialize();

	return (iResult);
}


// ---------------------------------------------------------------------------
// OverrideWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for Override dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
BOOL CALLBACK OverrideWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static HINSTANCE			hInstance;
	static LPDIRECTPLAY4A		lpDPlay;
	static LPDIRECTPLAYLOBBY3A	lpDPlayLobby;
	HRESULT						hr;

	switch(uMsg)
	{
	case WM_INITDIALOG:
		// Save the instance handle
		hInstance = (HINSTANCE)lParam;
			
		// Initialize dialog with launcher information
		lpDPlay = NULL;
		lpDPlayLobby = NULL;
		hr = InitializeOverrideWindow(hWnd, &lpDPlayLobby);
		if FAILED(hr)
			SetDlgItemText(hWnd, IDC_STATUSEDIT, "Could not initialize DirectPlay");
		return TRUE;

	case WM_DESTROY:
		// Destroy launcher information in dialog
		DestroyOverrideWindow(hWnd, lpDPlay, lpDPlayLobby);
		break;	// continue with default handling

	case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_SPCOMBO:

			switch (HIWORD(wParam))
			{
			case CBN_SELCHANGE:
				UpdateAddressInfo(hWnd, lpDPlayLobby);
				return TRUE;
			}
			break;

		case IDC_HOSTBUTTON:

			SetDlgItemText(hWnd, IDC_STATUSEDIT, "Hosting...");
			hr = DoHostOrJoin(hInstance, hWnd, lpDPlayLobby, TRUE, &lpDPlay);
			if FAILED(hr)
				SetDlgItemText(hWnd, IDC_STATUSEDIT, "Failed to host");
			else
				SetDlgItemText(hWnd, IDC_STATUSEDIT, "Host successfull");
			return TRUE;

		case IDC_JOINBUTTON:

			SetDlgItemText(hWnd, IDC_STATUSEDIT, "Joining...");
			hr = DoHostOrJoin(hInstance, hWnd, lpDPlayLobby, FALSE, &lpDPlay);
			if FAILED(hr)
				SetDlgItemText(hWnd, IDC_STATUSEDIT, "Failed to join");
			else
				SetDlgItemText(hWnd, IDC_STATUSEDIT, "Join successfull");
			return TRUE;

		case IDCANCEL:
			// Return failure
			EndDialog(hWnd, TRUE);
			return TRUE;
		}

		break;
	}

	// Allow for default processing
	return FALSE;
}

HRESULT InitializeOverrideWindow(HWND hWnd, LPDIRECTPLAYLOBBY3A *lplpDPlayLobby)
{
	LPDIRECTPLAY4A			lpDPlay = NULL;
	LPDIRECTPLAYLOBBY3A		lpDPlayLobby3A = NULL;
	HRESULT 				hr;
		
	// create a temporary ANSI DirectPlay interface
	hr = CoCreateInstance(&CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER, 
						  &IID_IDirectPlay4A, (LPVOID*)&lpDPlay);
	if FAILED(hr)
		return (hr);

	// get ANSI DirectPlayLobby interface
	hr = CoCreateInstance(&CLSID_DirectPlayLobby, NULL, CLSCTX_INPROC_SERVER,
						  &IID_IDirectPlayLobby3A, (LPVOID *) &lpDPlayLobby3A);
	if FAILED(hr)
		goto FAILURE;

	// put all the service providers in combo box
	lpDPlay->lpVtbl->EnumConnections(lpDPlay, NULL, EnumConnectionsCallback, hWnd, 0);
	SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETCURSEL, (WPARAM) 0, (LPARAM) 0);

	// fill modem combo box with available modems
	FillModemComboBox(hWnd, lpDPlayLobby3A);

	// Limit Port number edit field to 5 digits
	SendDlgItemMessage(hWnd, IDC_PORTEDIT, EM_LIMITTEXT, (WPARAM) 5, (LPARAM) 0);

	// update display first service provider
	UpdateAddressInfo(hWnd, lpDPlayLobby3A);

	// return the ANSI lobby interface
	*lplpDPlayLobby = lpDPlayLobby3A;
	lpDPlayLobby3A = NULL;		// we no longer own it so don't free it below

	hr = DP_OK;

FAILURE:
	if (lpDPlay)
		lpDPlay->lpVtbl->Release(lpDPlay);
	if (lpDPlayLobby3A)
		lpDPlayLobby3A->lpVtbl->Release(lpDPlayLobby3A);

	return (hr);
}

void DestroyOverrideWindow(HWND hWnd, LPDIRECTPLAY4A lpDPlay, LPDIRECTPLAYLOBBY3A lpDPlayLobby)
{
	// delete combo box data items
	DeleteServiceProviderCombo(hWnd);

	// release the dplay interface
	if (lpDPlay)
		lpDPlay->lpVtbl->Release(lpDPlay);

	// release the lobby interface
	if (lpDPlayLobby)
		lpDPlayLobby->lpVtbl->Release(lpDPlayLobby);
}

// ---------------------------------------------------------------------------
// EnumConnectionsCallback
// ---------------------------------------------------------------------------
// Description: Enumeration callback called by DirectPlay.
//              Enumerates service providers registered with DirectPlay.
// Arguments:
//  LPGUID      [in] GUID of service provider
//  LPVOID      [in] connection data (a DirectPlay Address) (NOT USED)
//  DWORD       [in] size of connection data (NOT USED)
//  LPCDPNAME   [in] name of service provider
//  DWORD       [in] connection flags (NOT USED)
//  LPVOID      [in] user-defined context
// Returns:
//  BOOL        TRUE to continue enumerating
BOOL FAR PASCAL EnumConnectionsCallback(LPCGUID lpguidSP, LPVOID lpConnection,
										DWORD dwConnectionSize,
										LPCDPNAME lpName, DWORD dwFlags,
										LPVOID lpContext)
{
	HWND		hWnd = lpContext;
	LRESULT 	iIndex;
	LPGUID		lpGuid;

	// store service provider name in combo box
	iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, 0,
								(LPARAM) lpName->lpszShortNameA);
	if (iIndex == CB_ERR)
		goto FAILURE;

	// make space for application GUID
	lpGuid = (LPGUID) GlobalAllocPtr(GHND, sizeof(GUID));
	if (lpGuid == NULL)
		goto FAILURE;

	// store pointer to GUID in combo box
	*lpGuid = *lpguidSP;
	SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid);

FAILURE:
	return (TRUE);
}

HRESULT GetServiceProviderGuid(HWND hWnd, LPGUID lpguidServiceProvider)
{
	LONG	iIndex;

	// get guid for service provider
	iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETCURSEL,
								(WPARAM) 0, (LPARAM) 0);
	if (iIndex == CB_ERR)
		return (DPERR_GENERIC);

	iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA,
								(WPARAM) iIndex, (LPARAM) 0);
	if ((iIndex == CB_ERR) || (iIndex == 0))
		return (DPERR_GENERIC);

	*lpguidServiceProvider = *((LPGUID) iIndex);

	return (DP_OK);
}

void DeleteServiceProviderCombo(HWND hWnd)
{
	WPARAM	i;
	LONG	lpData;
	
	// destroy the data stored with each combo box item
	i = 0;
	while (TRUE)
	{
		// get data pointer stored with item
		lpData = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_GETITEMDATA,
									(WPARAM) i, (LPARAM) 0);
		if (lpData == CB_ERR)			// error getting data
			break;

		if (lpData)						// data to delete
			GlobalFreePtr((LPVOID) lpData);

		i += 1;
	}

	// delete all items in list
	SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_RESETCONTENT,
								(WPARAM) 0, (LPARAM) 0);
}

void DeleteSessionInstanceList(HWND hWnd)
{
	WPARAM	i;
	LONG	lpData;
	
	// destroy the GUID's stored with each session name
	i = 0;
	while (TRUE)
	{
		// get data pointer stored with item
		lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA,
									(WPARAM) i, (LPARAM) 0);
		if (lpData == CB_ERR)			// error getting data
			break;

		if (lpData) 					// data to delete
			GlobalFreePtr((LPVOID) lpData);

		i += 1;
	}

	// delete all items in list
	SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_RESETCONTENT,
								(WPARAM) 0, (LPARAM) 0);
}

void SelectSessionInstance(HWND hWnd, LPGUID lpguidSessionInstance)
{
	WPARAM	i, iIndex;
	LONG	lpData;
	
	// loop over the GUID's stored with each session name
	// to find the one that matches what was passed in
	i = 0;
	iIndex = 0;
	while (TRUE)
	{
		// get data pointer stored with item
		lpData = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA,
									(WPARAM) i, (LPARAM) 0);
		if (lpData == CB_ERR)			// error getting data
			break;

		if (lpData == 0)				// no data to compare to
			continue;

		// guid matches
		if (IsEqualGUID(lpguidSessionInstance, (LPGUID) lpData))
		{
			iIndex = i; 				// store index of this string
			break;
		}

		i += 1;
	}

	// select this item
	SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_SETCURSEL, (WPARAM) iIndex, (LPARAM) 0);
}

HRESULT GetSessionInstanceGuid(HWND hWnd, LPGUID lpguidSessionInstance)
{
	LONG	iIndex;

	// get guid for session
	iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCURSEL,
								(WPARAM) 0, (LPARAM) 0);
	if (iIndex == LB_ERR)
		return (DPERR_GENERIC);

	iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETITEMDATA,
								(WPARAM) iIndex, (LPARAM) 0);
	if ((iIndex == LB_ERR) || (iIndex == 0))
		return (DPERR_GENERIC);

	*lpguidSessionInstance = *((LPGUID) iIndex);

	return (DP_OK);
}

BOOL FAR PASCAL EnumSessionsCallback(
						LPCDPSESSIONDESC2	lpSessionDesc,
						LPDWORD 			lpdwTimeOut,
						DWORD				dwFlags,
						LPVOID				lpContext)
{
	HWND		hWnd = (HWND) lpContext;
	LPGUID		lpGuid;
	LONG		iIndex;

	// see if last session has been enumerated
	if (dwFlags & DPESC_TIMEDOUT)
		return (FALSE);

	// store session name in list
	iIndex = SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_ADDSTRING, 
								(WPARAM) 0, (LPARAM) lpSessionDesc->lpszSessionNameA);

	if (iIndex == LB_ERR)
		goto FAILURE;


	// make space for session instance guid
	lpGuid = (LPGUID) GlobalAllocPtr( GHND, sizeof(GUID) );
	if (lpGuid == NULL)
		goto FAILURE;

	// store pointer to guid in list
	*lpGuid = lpSessionDesc->guidInstance;
	SendDlgItemMessage( hWnd, IDC_SESSIONLIST, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) lpGuid);

FAILURE:
	return (TRUE);
}

BOOL CALLBACK SessionsWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static LPSTATUSCONTEXT	lpContext;
	static LPDIRECTPLAY4A	lpDPlay;
	static UINT 			idTimer;
	static BOOL 			bInsideEnumSessions;
	DPSESSIONDESC2			sessionDesc;
	GUID					guidSessionInstance;
	LONG					iIndex;
	HRESULT 				hr;

	switch(uMsg)
	{
	case WM_INITDIALOG:
			lpContext = (LPSTATUSCONTEXT) lParam;
			lpDPlay = lpContext->lpDPlay;
			bInsideEnumSessions = FALSE;

			// can't join until there is a session
			EnableDlgButton(hWnd, IDC_JOINSESSIONBUTTON, FALSE);

			// set a timer to refresh the session list
			idTimer = SetTimer(hWnd, TIMERID, TIMERINTERVAL, NULL);
		break;

	case WM_DESTROY:
			if (idTimer)
			{
				KillTimer(hWnd, idTimer); 
				idTimer = 0;
			}
			DeleteSessionInstanceList(hWnd);
		break;

		case WM_TIMER:
			// make sure we don't re-enter EnumSessions
			if (bInsideEnumSessions)
				break;

			// get guid of currently selected session
			guidSessionInstance = GUID_NULL;
			hr = GetSessionInstanceGuid(hWnd, &guidSessionInstance);

			// delete existing session list
			DeleteSessionInstanceList(hWnd);

			// enum sessions
			ZeroMemory(&sessionDesc, sizeof(DPSESSIONDESC2));
			sessionDesc.dwSize = sizeof(DPSESSIONDESC2);
			sessionDesc.guidApplication = OVERRIDE_GUID;

			bInsideEnumSessions = TRUE;
			hr = lpDPlay->lpVtbl->EnumSessions(lpDPlay, &sessionDesc, 0,
									EnumSessionsCallback, hWnd,
									DPENUMSESSIONS_AVAILABLE |
									DPENUMSESSIONS_ASYNC |
									DPENUMSESSIONS_RETURNSTATUS);
			bInsideEnumSessions = FALSE;

			// select the session that was previously selected
			SelectSessionInstance(hWnd, &guidSessionInstance);

			// hilite "Join" button only if there are sessions to join
			iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_GETCOUNT,
								   (WPARAM) 0, (LPARAM) 0);

			EnableDlgButton(hWnd, IDC_JOINSESSIONBUTTON, (iIndex > 0) ? TRUE : FALSE);

			switch (hr)
			{
			case DP_OK:
				SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Searching for sessions...");
				break;

			case DPERR_CONNECTING:
				SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Making connection...");
				break;

			case DPERR_NOCONNECTION:
				SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Connection failed");
				KillTimer(hWnd, idTimer); 
				idTimer = 0;
				break;

			default:
				SetDlgItemText(hWnd, IDC_SESSIONSTATUSEDIT, "Error making connection");
				KillTimer(hWnd, idTimer); 
				idTimer = 0;
				break;
			}
			break;
	
		case WM_COMMAND:
		switch(LOWORD(wParam))
		{
		case IDC_JOINSESSIONBUTTON:
			// Return guid of session to join
					hr = GetSessionInstanceGuid(hWnd, &lpContext->guidInstance);
					if SUCCEEDED(hr)
						EndDialog(hWnd, TRUE);
			break;

		case IDCANCEL:
			// Return failure
			EndDialog(hWnd, FALSE);
			break;
		}

		break;
	}

	// Allow for default processing
	return FALSE;
}

// ---------------------------------------------------------------------------
// UpdateAddressInfo
// ---------------------------------------------------------------------------
// Description:  Updates address information elements in dialog.
//               Calls EnumAddressTypes() to determine what address
//               information should be displayed and arranges dialog
//               to display and collect the needed information.
// Arguments:
//  HWND                    [in] window handle
//  LPDIRECTPLAYLOBBY3A     [in] DirectPlay Lobby interface to use
// Returns:
//  HRESULT                 DP_OK if it succeedes, otherwise the error
HRESULT UpdateAddressInfo(HWND hWnd, LPDIRECTPLAYLOBBY3A lpDPlayLobby3A)
{
	GUID		guidServiceProvider;
	HRESULT 	hr;

	// clear and hide address dialog items
	ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDIT), SW_HIDE);
	ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDITLABEL), SW_HIDE);

	ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBO), SW_HIDE);
	ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBOLABEL), SW_HIDE);

	ShowWindow(GetDlgItem(hWnd, IDC_TCPEDIT), SW_HIDE);
	ShowWindow(GetDlgItem(hWnd, IDC_TCPEDITLABEL), SW_HIDE);

	ShowWindow(GetDlgItem(hWnd, IDC_PORTEDIT), SW_HIDE);
	ShowWindow(GetDlgItem(hWnd, IDC_PORTEDITLABEL), SW_HIDE);

	ShowWindow(GetDlgItem(hWnd, IDC_IPXLABEL), SW_HIDE);

	ShowWindow(GetDlgItem(hWnd, IDC_SERVICEPROVIDERLABEL), SW_HIDE);

	// get currently selected service provider
	hr = GetServiceProviderGuid(hWnd, &guidServiceProvider);
	if FAILED(hr)
		goto FAILURE;

	// modem service provider
	if (IsEqualGUID(&guidServiceProvider, &DPSPGUID_MODEM))
	{
		// show edit control to collect phone number
		ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDIT), SW_SHOW);
		ShowWindow(GetDlgItem(hWnd, IDC_PHONEEDITLABEL), SW_SHOW);

		// show combo box to collect modem
		ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBO), SW_SHOW);
		ShowWindow(GetDlgItem(hWnd, IDC_MODEMCOMBOLABEL), SW_SHOW);
	}

	// internet TCP/IP service provider
	else if (IsEqualGUID(&guidServiceProvider, &DPSPGUID_TCPIP))
	{
		// show edit control to collect IP address
		ShowWindow(GetDlgItem(hWnd, IDC_TCPEDIT), SW_SHOW);
		ShowWindow(GetDlgItem(hWnd, IDC_TCPEDITLABEL), SW_SHOW);

		// show edit control to collect TCP port number
		ShowWindow(GetDlgItem(hWnd, IDC_PORTEDIT), SW_SHOW);
		ShowWindow(GetDlgItem(hWnd, IDC_PORTEDITLABEL), SW_SHOW);
	}

	// IPX service provider
	else if (IsEqualGUID(&guidServiceProvider, &DPSPGUID_IPX))
	{
		// no address info is needed, so just display a string
		ShowWindow(GetDlgItem(hWnd, IDC_IPXLABEL), SW_SHOW);
	}

	// anything else, let service provider collect settings, if any
	else
	{
		ShowWindow(GetDlgItem(hWnd, IDC_SERVICEPROVIDERLABEL), SW_SHOW);
	}

FAILURE:
	return (hr);
}

HRESULT CreateServiceProviderAddress(HWND hWnd, LPDIRECTPLAYLOBBY3A lpDPlayLobby,
									 LPVOID *lplpAddress, LPDWORD lpdwAddressSize)
{
	DPCOMPOUNDADDRESSELEMENT	addressElements[3];
	CHAR						szIPAddressString[NAMEMAX];
	CHAR						szPhoneNumberString[NAMEMAX];
	CHAR						szModemString[NAMEMAX];
	LPVOID						lpAddress = NULL;
	DWORD						dwAddressSize = 0;
	DWORD						dwElementCount;
	GUID						guidServiceProvider;
	WORD						wPort;
	HRESULT 					hr;

	// get currently selected service provider
	hr = GetServiceProviderGuid(hWnd, &guidServiceProvider);
	if FAILED(hr)
		goto FAILURE;

	dwElementCount = 0;

	if (IsEqualGUID(&guidServiceProvider, &DPSPGUID_MODEM))
	{
		// Modem needs a service provider, a phone number string and a modem string

		// service provider
		addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider;
		addressElements[dwElementCount].dwDataSize = sizeof(GUID);
		addressElements[dwElementCount].lpData = (LPVOID) &DPSPGUID_MODEM;
		dwElementCount++;

		// add a modem string if available
		lstrcpy(szModemString, "");
		if (GetDlgItemText(hWnd, IDC_MODEMCOMBO, szModemString, NAMEMAX))
		{
			addressElements[dwElementCount].guidDataType = DPAID_Modem;
			addressElements[dwElementCount].dwDataSize = lstrlen(szModemString) + 1;
			addressElements[dwElementCount].lpData = szModemString;
			dwElementCount++;
		}

		// add phone number string
		lstrcpy(szPhoneNumberString, "");
		GetDlgItemText(hWnd, IDC_PHONEEDIT, szPhoneNumberString, NAMEMAX);
		addressElements[dwElementCount].guidDataType = DPAID_Phone;
		addressElements[dwElementCount].dwDataSize = lstrlen(szPhoneNumberString) + 1;
		addressElements[dwElementCount].lpData = szPhoneNumberString;
		dwElementCount++;
	}

	// internet TCP/IP service provider
	else if (IsEqualGUID(&guidServiceProvider, &DPSPGUID_TCPIP))
	{
		// TCP/IP needs a service provider, an IP address, and optional port #

		// service provider
		addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider;
		addressElements[dwElementCount].dwDataSize = sizeof(GUID);
		addressElements[dwElementCount].lpData = (LPVOID) &DPSPGUID_TCPIP;
		dwElementCount++;

		// IP address string
		lstrcpy(szIPAddressString, "");
		GetDlgItemText(hWnd, IDC_TCPEDIT, szIPAddressString, NAMEMAX);
		addressElements[dwElementCount].guidDataType = DPAID_INet;
		addressElements[dwElementCount].dwDataSize = lstrlen(szIPAddressString) + 1;
		addressElements[dwElementCount].lpData = szIPAddressString;
		dwElementCount++;

		// Optional Port number
		wPort = (WORD)GetDlgItemInt(hWnd, IDC_PORTEDIT, NULL, FALSE);
		if (wPort > 0)
		{
			addressElements[dwElementCount].guidDataType = DPAID_INetPort;
			addressElements[dwElementCount].dwDataSize = sizeof(WORD);
			addressElements[dwElementCount].lpData = &wPort;
			dwElementCount++;
		}
	}

	// IPX service provider
	else if (IsEqualGUID(&guidServiceProvider, &DPSPGUID_IPX))
	{
		// IPX just needs a service provider

		// service provider
		addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider;
		addressElements[dwElementCount].dwDataSize = sizeof(GUID);
		addressElements[dwElementCount].lpData = (LPVOID) &DPSPGUID_IPX;
		dwElementCount++;
	}

	// anything else, let service provider collect settings, if any
	else
	{
		// service provider
		addressElements[dwElementCount].guidDataType = DPAID_ServiceProvider;
		addressElements[dwElementCount].dwDataSize = sizeof(GUID);
		addressElements[dwElementCount].lpData = (LPVOID) &guidServiceProvider;
		dwElementCount++;
	}

	// see how much room is needed to store this address
	hr = lpDPlayLobby->lpVtbl->CreateCompoundAddress(lpDPlayLobby,
						addressElements, dwElementCount,
						NULL, &dwAddressSize);
	if (hr != DPERR_BUFFERTOOSMALL)
		goto FAILURE;

	// allocate space
	lpAddress = GlobalAllocPtr(GHND, dwAddressSize);
	if (lpAddress == NULL)
	{
		hr = DPERR_NOMEMORY;
		goto FAILURE;
	}

	// create the address
	hr = lpDPlayLobby->lpVtbl->CreateCompoundAddress(lpDPlayLobby,
						addressElements, dwElementCount,
						lpAddress, &dwAddressSize);
	if FAILED(hr)
		goto FAILURE;

	// return the address info
	*lplpAddress = lpAddress;
	*lpdwAddressSize = dwAddressSize;

	return (DP_OK);

FAILURE:
	if (lpAddress)
		GlobalFreePtr(lpAddress);

	return (hr);
}

HRESULT DoHostOrJoin(HINSTANCE hInstance, HWND hWnd, LPDIRECTPLAYLOBBY3A lpDPlayLobby, BOOL bHost, LPDIRECTPLAY4A *lplpDPlay)
{
	LPDIRECTPLAY4A	lpDPlay = NULL;
	LPVOID			lpAddress = NULL;
	DWORD			dwAddressSize = 0;
	DPSESSIONDESC2	sessionDesc;
	STATUSCONTEXT	statusContext;
	HRESULT 		hr;

	// bail if we don't have a lobby interface
	if (lpDPlayLobby == NULL)
		return (DPERR_INVALIDOBJECT);

	// get service provider address from information in dialog
	hr = CreateServiceProviderAddress(hWnd, lpDPlayLobby, &lpAddress, &dwAddressSize);
	if FAILED(hr)
		goto FAILURE;

	// interface already exists, so release it
	if (*lplpDPlay)
	{
		(*lplpDPlay)->lpVtbl->Close(*lplpDPlay);
		(*lplpDPlay)->lpVtbl->Release(*lplpDPlay);
		*lplpDPlay = NULL;
	}

	// create an ANSI DirectPlay4 interface
	hr = CoCreateInstance(&CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER, 
						  &IID_IDirectPlay4A, (LPVOID*)&lpDPlay);
	if FAILED(hr)
		goto FAILURE;

	// initialize the connection using the address
	hr = lpDPlay->lpVtbl->InitializeConnection(lpDPlay, lpAddress, 0);
	if FAILED(hr)
		goto FAILURE;

	if (bHost)
	{
		// host a new session
		ZeroMemory(&sessionDesc, sizeof(DPSESSIONDESC2));
		sessionDesc.dwSize = sizeof(DPSESSIONDESC2);
		sessionDesc.dwFlags = DPSESSION_MIGRATEHOST | DPSESSION_KEEPALIVE;
		sessionDesc.guidApplication = OVERRIDE_GUID;
		sessionDesc.dwMaxPlayers = 0;
		sessionDesc.lpszSessionNameA = "Override";

		// open it
		hr = lpDPlay->lpVtbl->Open(lpDPlay, &sessionDesc, DPOPEN_CREATE);
	}

	// enumerate the sessions
	else
	{
		// display status dialog and enumerate until we find a session
		statusContext.lpDPlay = lpDPlay;
		statusContext.guidInstance = GUID_NULL;

		if (!DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SESSIONSDIALOG), hWnd, SessionsWndProc, (LPARAM) &statusContext))
		{
			hr = DPERR_USERCANCEL;
			goto FAILURE;
		}

		// open the session selected by the use
		ZeroMemory(&sessionDesc, sizeof(DPSESSIONDESC2));
		sessionDesc.dwSize = sizeof(DPSESSIONDESC2);
		sessionDesc.guidApplication = OVERRIDE_GUID;
		sessionDesc.guidInstance = statusContext.guidInstance;

		// open it
		hr = lpDPlay->lpVtbl->Open(lpDPlay, &sessionDesc, DPOPEN_JOIN);
	}

	if FAILED(hr)
		goto FAILURE;

	// return the connected interface
	*lplpDPlay = lpDPlay;

	// set to NULL so we don't release it below
	lpDPlay = NULL;

FAILURE:
	if (lpDPlay)
	{
		lpDPlay->lpVtbl->Close(lpDPlay);
		lpDPlay->lpVtbl->Release(lpDPlay);
	}

	if (lpAddress)
		GlobalFreePtr(lpAddress);

	return (hr);
}

// ---------------------------------------------------------------------------
// EnumModemAddress
// ---------------------------------------------------------------------------
// Description: Enumeration callback called by DirectPlayLobby.
//              Enumerates the DirectPlay address chunks. If the
//              chunk contains modem strings, add them to the control.
// Arguments:
//  REFGUID     [in] GUID of the address type
//  DWORD       [in] size of chunk
//  LPVOID      [in] pointer to chunk
//  LPVOID      [in] user-defined context
// Returns:
//  BOOL        FALSE to stop enumerating after the first callback
BOOL FAR PASCAL EnumModemAddress(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	HWND	hWnd = (HWND) lpContext;
	LPSTR	lpszStr = (LPSTR) lpData;

	// modem
	if (IsEqualGUID(lpguidDataType, &DPAID_Modem))
	{
		// loop over all strings in list
		while (lstrlen(lpszStr))
		{
			// store modem name in combo box
			SendDlgItemMessage(hWnd, IDC_MODEMCOMBO, CB_ADDSTRING, 0, (LPARAM) lpszStr);

			// skip to next string
			lpszStr += lstrlen(lpszStr) + 1;
		}
	}

	return (TRUE);
}

// ---------------------------------------------------------------------------
// FillModemComboBox
// ---------------------------------------------------------------------------
// Description:             Fills combo box with modem names
// Arguments:
//  HWND                    [in]  Window handle.
//  LPDIRECTPLAYLOBBY3A     [in]  DirectPlay Lobby interface to use
// Returns:
//  HRESULT                 any error
HRESULT FillModemComboBox(HWND hWnd, LPDIRECTPLAYLOBBY3A lpDPlayLobby)
{
	LPDIRECTPLAY		lpDPlay1 = NULL;
	LPDIRECTPLAY4A		lpDPlay4A = NULL;
	LPVOID				lpAddress = NULL;
	DWORD				dwAddressSize = 0;
	GUID				guidServiceProvider = DPSPGUID_MODEM;
	HRESULT 			hr;

	// Use the obsolete DirectPlayCreate() as quick way to load a specific
	// service provider.  Trade off using DirectPlayCreate() and
	// QueryInterface() vs using CoCreateInitialize() and building a
	// DirectPlay Address for InitializeConnection().
	hr = DirectPlayCreate(&guidServiceProvider, &lpDPlay1, NULL);
	if FAILED(hr)
		goto FAILURE;

	// query for an ANSI DirectPlay4 interface
	hr = lpDPlay1->lpVtbl->QueryInterface(lpDPlay1, &IID_IDirectPlay4A, (LPVOID *) &lpDPlay4A);
	if FAILED(hr)
		goto FAILURE;

	// get size of player address for player zero
	hr = lpDPlay4A->lpVtbl->GetPlayerAddress(lpDPlay4A, DPID_ALLPLAYERS, NULL, &dwAddressSize);
	if (hr != DPERR_BUFFERTOOSMALL)
		goto FAILURE;

	// make room for it
	lpAddress = GlobalAllocPtr(GHND, dwAddressSize);
	if (lpAddress == NULL)
	{
		hr = DPERR_NOMEMORY;
		goto FAILURE;
	}

	// get the address
	hr = lpDPlay4A->lpVtbl->GetPlayerAddress(lpDPlay4A, DPID_ALLPLAYERS, lpAddress, &dwAddressSize);
	if FAILED(hr)
		goto FAILURE;
	
	// get modem strings from address and put them in the combo box
	hr = lpDPlayLobby->lpVtbl->EnumAddress(lpDPlayLobby, EnumModemAddress, 
							 lpAddress, dwAddressSize, hWnd);
	if FAILED(hr)
		goto FAILURE;

	// select first item in list
	SendDlgItemMessage(hWnd, IDC_MODEMCOMBO, CB_SETCURSEL, (WPARAM) 0, 0);

FAILURE:
	if (lpDPlay1)
		lpDPlay1->lpVtbl->Release(lpDPlay1);
	if (lpDPlay4A)
		lpDPlay4A->lpVtbl->Release(lpDPlay4A);
	if (lpAddress)
		GlobalFreePtr(lpAddress);

	return (hr);
}

BOOL DlgItemIsChecked(HWND hDlg, int nIDDlgItem)
{
	return ((SendDlgItemMessage(hDlg, nIDDlgItem, BM_GETCHECK, (WPARAM) 0, (LPARAM) 0) == BST_CHECKED) ? TRUE : FALSE);
}

void EnableDlgButton(HWND hDlg, int nIDDlgItem, BOOL bEnable)
{
	EnableWindow(GetDlgItem(hDlg, nIDDlgItem), bEnable);
}

void ErrorBox(LPSTR lpszErrorStr, HRESULT hr)
{
	char	szStr[MAXSTRLEN];

	wsprintf(szStr, lpszErrorStr, hr);

	MessageBox(NULL, szStr, "DPLaunch Error", MB_OK);
}

